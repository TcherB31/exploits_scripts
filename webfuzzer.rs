extern crate regex;
extern crate reqwest;
use regex::Regex;
use std::{io, fs};

const FRONT_OF_LINK: &str = "https://";
const MATCHING_STRING: &str = "This domain name has been registered";
static FUZZING_WORD_LIST_REGEX: &Regex = &Regex::new(r"^\w+$").unwrap();
fn print_iterator(iterator: &str) {
    println!("{}", iterator);
}
fn go_through_link(file_name: String) -> String {
    let mut file_name_string = String::new();
    let file = fs::File::open(file_name).unwrap();
    let reader = io::BufReader::new(file);
    for line in reader.lines() {
        let line_string = line.unwrap();
        file_name_string = line_string;
    }
    let domain_name = file_name_string.split(",").collect::<Vec<&str>>()[0];
    if domain_name.contains(FRONT_OF_LINK) {
        let trimmed_domain_name = domain_name.trim_start_matches(FRONT_OF_LINK);
        let mut fuzzing_word_list_file = fs::File::open("fuzzing_word_list.txt").unwrap();
        let fuzzing_word_list_reader = io::BufReader::new(fuzzing_word_list_file);
        for line in fuzzing_word_list_reader.lines() {
            let mut word_to_fuzz = line.unwrap();
            let unfuzzed_link = FRONT_OF_LINK.to_string() + trimmed_domain_name + "/" + word_to_fuzz;
            let response = reqwest::get(&unfuzzed_link).unwrap();
            let body = response.text().unwrap();
            if body.contains(MATCHING_STRING) {
                print_iterator(&unfuzzed_link);
            }
        }
    } else {
        println!("Error: Link does not contain {}", FRONT_OF_LINK);
    }
    domain_name.to_string()
}
fn main() {
    println!("Please enter the domain name file");
    let mut file_name = String::new();
    io::stdin().read_line(&mut file_name).unwrap();
    if file_name.is_empty() {
        println!("Please enter a valid file name");
    }
    go_through_link(file_name);
}
